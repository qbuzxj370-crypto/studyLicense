# 언어 기능

# 예외 처리

## 예외 처리 (Exception Handling)

### 개요

프로그램의 정상적인 실행을 방해하는 조건이나 상태를 예외(Exception)라 하며 이러한 예외 발생 시 프로그래머가 해당 문제에 대비해 작성해 놓은 루틴을 수행하도록 하는 것이 예외 처리

- 예외 발생 시 일반적인 처리 루틴은 프로그램을 종료시키거나 로그를 남기도록 하는 것
- C++, Ada, java, 자바스크립트와 같은 언어는 예외 처리 기능이 내장되어 있으며 그 외의 언어에서는 필요한 경우 조건문을 이용해 예외 루틴을 작성
- 예외의 원인에는 하드웨어 문제, 운영체제의 설정 실수, 라이브러리의 손상, 사용자의 입력 실수, 받아들일 수 없는 연산, 할당하지 못하는 기억장치 접근 등 다종다양

### 예외(Exception) vs 오류(Error)

Java 기준으로 예외/오류는 Throwable 하위로 구분된다.

- Error: JVM/시스템 수준의 심각한 문제(예: OutOfMemoryError)로, 일반적으로 애플리케이션이 복구를 시도하기 어렵고 보통 처리 대상이 아님
- Exception: 프로그램에서 예측/처리 가능한 수준의 문제로, try-catch 또는 throws로 처리 대상

## Java의 예외 처리

Java에서는 예외를 객체로 취급하며 예외와 관련된 클래스를 java.lang 패키지에서 제공

- try ~ catch 문을 이용해 예외를 처리
- try 블록 내 코드를 수행하다가 예외 발생 시 try 블록의 나머지 코드는 실행되지 않고, 해당 예외를 처리하는 catch 블록으로 이동하여 예외 처리 코드를 수행
    - catch에서 처리되면 try-catch 문 다음 코드부터 정상 흐름으로 계속 실행
- catch 블록에서 선언한 변수는 해당 catch 블록에서만 유효
- try ~ catch 문 안에 또 다른 try ~ catch 포함 가능
- try ~ catch 문 내의 실행 코드가 한 줄만 있어도 중괄호({ }) 생략 불가

### finally

- finally 블록은 예외 발생 여부와 관계없이(catch로 처리되든, 예외가 던져지든) 항상 실행되는 블록
- 주로 **자원 해제(파일/소켓/락 해제 등)**에 사용
    
    (단, System.exit() 등 특수 상황에서는 실행되지 않을 수 있음)
    

형식:

- `try { ... } catch (...) { ... } finally { ... }`

### throws (예외 전가)

- 메서드 내부에서 예외를 직접 처리하지 않고, **호출한 쪽(상위 호출자)에게 예외 처리를 맡기는 선언**
- 메서드 시그니처에 throws 예외타입을 명시

핵심:

- “내가 처리 안 할 테니 **호출자가 처리해라**” 또는 “상위로 전달한다”

### Checked / Unchecked 예외

Java 예외는 크게 두 종류로 나뉜다.

- **Checked Exception** : 컴파일러가 반드시 처리(try-catch)하거나 선언(throws) 하도록 강제
    
    예: IOException, ClassNotFoundException 등
    
- **Unchecked Exception** (RuntimeException 계열) : 컴파일러가 강제하지 않음(선택적으로 처리)
    
    예: NullPointerException, IllegalArgumentException, ArithmeticException 등
    

### **주요 예외 객체**

| 예외 객체 | 발생 원인 |
| --- | --- |
| ClassNotFoundException | 클래스를 찾지 못한 경우 |
| NoSuchMethodException | 메소드를 찾지 못한 경우 |
| FileNotFoundException | 파일을 찾지 못한 경우 |
| InterruptedIOException | 입·출력 처리가 중단된 경우 |
| ArithmeticException | 0으로 나누는 등의 산술 연산 예외가 발생한 경우 |
| IllegalArgumentException | 잘못된 인자를 전달한 경우 |
| NumberFormatException | 숫자 형식으로 변환할 수 없는 문자열을 숫자 형식으로 변환한 경우 |
| ArrayIndexOutOfBoundsException | 배열의 범위를 벗어난 접근을 시도한 경우 |
| NegativeArraySizeException | 0보다 작은 값으로 배열의 크기를 지정한 경우 |
| NullPointerException | 존재하지 않는 객체를 참조한 경우 |

# 프로토타입

## 프로토타입 (Prototype)

함수 원형(Function Prototype)이라는 의미

- 컴파일러에게 사용될 함수에 대한 정보를 미리 알려주는 선언 (반환타입, 함수명, 매개변수 타입/개수 등의 시그니처)
- 같은 번역 단위에서 함수 정의가 호출보다 앞에 있으면 별도 선언이 필요 없을 수 있다. 다만 다른 파일/라이브러리 함수는 헤더를 통해 선언(프로토타입)을 제공해야 한다.
- 프로토타입은 함수 정의에서 본문만 제거한 형태이며, *매개변수의 타입/개수*를 명시한다(이름은 생략 가능).
- 반환형과 매개변수 리스트(개수/타입)가 함수 정의와 일치(또는 호환)

### C언어에서의 프로토타입 선언

main() 함수 밖에 선언

**기본 형식**

반환타입 함수명(매개변수1, 매개변수2,•••);

- 반환 타입 : 반환될 값의 자료형을 작성, 없으면 반환값이 없으면 void 입력
- 함수명 : 사용할 함수의 이름. 사용자의 임의 설정 가능
- (매개변수1, 매개변수2,•••) : 함수에서 사용할 매개 변수, 호출부에서 보내는 값의 순서와 자료형이 반드시 일치해야 한다.

**`f()` vs `f(void)` 주의 (C)**

- `int f(void);` : 매개변수 없음을 명확히 의미하는 “정확한 프로토타입”
- `int f();` : (C에서) 매개변수 정보 미지정 선언(옛 스타일) → 호출 시 타입 체크가 약해질 수 있음
- “인자 없음”을 표현하려면 **`(void)`**를 쓰는 것이 안전