# 기본 문법

# 데이터/연산자

## **데이터 타입과 변수**

### **데이터 타입 (Data Type)**

변수에 저장될 데이터의 형식

변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값을 저장할지 데이터 타입을 지정하여 변수를 선언해야 한다.

- 정수 타입 (Integer Type)
    - 정수(소숫점이 없는 숫자)를 저장할 때 사용
- 부동 소수점 타입 (Floating Point Type)
    - 소수점 이하가 있는 실수를 저장할 때 사용
- 문자 타입 (Character Type)
    - 한 문자를 저장할 때 사용
    - 작은 따옴표(’ ’) 안에 표시
- 문자열 타입 (Character String Type)
    - 문자열을 저장할 때 사용
    - 큰 따옴표(” ”) 안에 표시
- 불린 타입 (Boolean Type)
    - 조건의 참(True), 거짓(False) 여부를 판단하여 저장할 때 사용
    - 기본 값은 거짓(False)
- 배열 타입 (Array Type)
    - 같은 타입의 데이터 집합을 만들어 저장할 때 사용
    - 데이터는 중괄호({ }) 안에 콤마(,)로 구분하여 값들을 나열

**C/C++의 데이터 타입 크기 및 기억 범위**

문자형

- char
    - 크기: 1Byte
    - 기억 범위: -128 ~ 127
        - C 언어에서 char는 정수형이며 ASCII로 정해진 해석 규칙에 따라 정수를 문자로 치환하여 출력
        - 음수도 저장해서 정수로 사용 가능하나 출력은 불가

부호 없는 문자형

- unsigned char
    - 크기: 1Byte
    - 기억 범위: 0 ~ 255

정수형

- short
    - 크기: 2Byte
    - 기억 범위: -32,768 ~ 32,767
- int
    - 크기: 4Byte
    - 기억 범위: -2,147,483,648 ~ 2,147,483,647
- long
    - 크기: 4Byte
    - 기억 범위: -2,147,483,648 ~ 2,147,483,647
- long long
    - 크기: 8Byte
    - 기억 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

부호 없는 정수형

- unsigned short
    - 크기: 2Byte
    - 기억 범위: 0 ~ 65,535
- unsigned int
    - 크기: 4Byte
    - 기억 범위: 0 ~ 4,294,967,295
- unsigned long
    - 크기: 4Byte
    - 기억 범위: 0 ~ 4,294,967,295

실수형

- float
    - 크기: 4Byte
    - 기억 범위: 1.2 × 10⁻³⁸ ~ 3.4 × 10³⁸
- double
    - 크기: 8Byte
    - 기억 범위: 2.2 × 10⁻³⁰⁸ ~ 1.8 × 10³⁰⁸
- long double
    - 크기: 8Byte
    - 기억 범위: 2.2 × 10⁻³⁰⁸ ~ 1.8 × 10³⁰⁸

**JAVA의 데이터 타입 크기 및 기억 범위**

문자

- char
    - 크기: 2Byte
    - 기억 범위: 0 ~ 65,535

정수

- byte
    - 크기: 1Byte
    - 기억 범위: -128 ~ 127
- short
    - 크기: 2Byte
    - 기억 범위: -32,768 ~ 32,767
- int
    - 크기: 4Byte
    - 기억 범위: -2,147,483,648 ~ 2,147,483,647
- long
    - 크기: 8Byte
    - 기억 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

실수

- float
    - 크기: 4Byte
    - 기억 범위: 1.4 × 10⁻⁴⁵ ~ 3.4 × 10³⁸
- double
    - 크기: 8Byte
    - 기억 범위: 4.9 × 10⁻³²⁴ ~ 1.8 × 10³⁰⁸

논리

- boolean
    - 크기: 1Byte
    - 기억 범위: true 또는 false

**Python**

문자

- str
    - 크기 : 무제한
    - 기억 범위 : 무제한

정수

- int
    - 크기 : 8Byte
    - 기억 범위 : 무제한

실수

- float
    - 크기 : 무제한
    - 기억 범위 : 4.9 × 10⁻³²⁴ ~ 1.8 × 10³⁰⁸
- complex
    - 복소수(실수부 + 허수부) 표현
    - 크기 : 16Byte
    - 기억 범위 : 실수부와 허수부 각각 4.9 × 10⁻³²⁴ ~ 1.8 × 10³⁰⁸

### 변수 (Variable)

컴퓨터기 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간

- 변할 수 있는 값을 의미
- 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분

**변수명 작성 규칙**

- 영문자, 숫자, _(under_bar) 사용 가능
- 영문자, _만 첫 글자로 사용 가능하며 숫자는 사용 불가
- 글자 수 제한은 없다.
- 공백이나 특수문자는 _ 제외 사용 불가
- 대•소문자 구분
- 예약어를 변수명으로 사용 불가
- 변수 선언 시 문장 마지막에 반드시 세미콜론(;) 필요

**예약어**

정해진 기능을 수행하도록 이미 용도가 정해져 있는 단어

변수명이나 다른 목적으로 사용 불가

**C언어**

제어문

- 반복
    - do, for, while
- 선택
    - case, default, else, if, switch
- 분기
    - break, continue, goto, return

자료형

- char, double, enum, float, int, long, short, signed, struct, typedef, union. unsigned, void

기억 클래스

- auto, extern, register, static

기타

- const, sizeof, volatile

**상수**

변수는 프로그램을 실행하는 도중  발생한 값을 저장하기 위한 값으로 변수의 값은 변경될 수 있다.

변수에 저장된 값이 프로그램 종료 시까지 변경되지 않도록 상수로 만들어 사용할 수 있다. 

C언어에서는 const라는 예약어를 사용하여 자료형의 앞•뒤에 붙인다.

변수처럼 상수에 이름을 붙여 기호화하여 사용한다고 하여 심볼릭(Symbolic) 상수라고도 한다.

**리터럴 (Literal)**

상수나 변수에 저장되는 값 그 자체

**기억 변수**

변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 기억영역이 할당되는데 할당되는 기억영역에 따라 사용 범위에 제한이 있다.

- 이러한 기억영역을 결정하는 작업이 기억 클래스(Storage Class)
- **C언어에서 제공하는 기억 클래스**

| 종류 | 기억영역 | 예약어 | 생존기간 | 사용 범위 |
| --- | --- | --- | --- | --- |
| 자동 변수 | 스택(Stack) | auto(생략) | 일시적 | 지역적 |
| 레지스터 변수 | 레지스터(Register) | register | 일시적 | 지역적 |
| 정적 변수(내부) | 데이터(Data) | static | 영구적 | 지역적 |
| 정적 변수(외부) | 데이터(Data) | static | 영구적 | 전역적 |
| 외부 변수 | 데이터(Data) | extern | 영구적 | 전역적 |
- **핵심 구분 포인트**
    - **일시적**: 함수/블록 실행 동안만 존재 (종료 시 소멸)
    - **영구적**: 프로그램 종료까지 유지
    - **지역적**: 선언된 블록/함수/파일 내부에서만 접근 가능
    - **전역적**: 프로그램 전체에서 접근 가능(다른 파일 포함 가능)
- **항목별 정리(예시 포함)**
    - 자동 변수 (automatic Variable)
        
        함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수
        
        - 기본 지역 변수는 자동 변수로 취급됨 → `auto`는 보통 생략
        - 기억영역: 스택(Stack)
        - 생존기간: 일시적
        - 사용 범위: 지역적
        - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸
        - 초기화하지 않으면 쓰레기값(Garbage Value)이 저장
        
        ```c
        void f() {
            int x = 10;      // auto (생략)
            auto int y = 20; // auto (표기 가능하지만 거의 안 씀)
        }
        ```
        
    - 레지스터 변수 (register Variable)
        - 메모리가 아닌 CPU 내부의 레지스터에 기억영역을 할당받는 변수
        - 자주 사용되는 변수를 레지스터에 저장하여 처리 속도를 높이기 위해 사용
        - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸
        - 레지스터의 사용 개수는 한정되어 있어 데이터를 저장할 레지스터가 없는 경우 자동 변소로 취급되어 메모리에 할당
        - CPU애 저장되어 메모리 주소를 구할 수 없어 변수의 주소를 구하는 주소 연산자(&) 사용 불가
        - 기억영역: 레지스터(Register)
        - 생존기간: 일시적
        - 사용 범위: 지역적
        
        ```c
        void f() {
        registerint i;
        for (i =0; i <10; i++) {}
        }
        ```
        
    - 정적 변수 (static Variable)
        
        함수 블록 내에서 선언하는 내부 정적 변수와 함수 외부에서 선언하는 외부 정적 변수로 구분
        
        - 함수나 블록 종료시에도 값이 소멸하지 않는다.
        - 초기화는 변수 선언 시 한 번만 가능하며 초기화 생략 시 0으로 자동 초기화
        - 정적 변수 (static) - 내부 정적 변수
            - 함수/블록 내부에 선언된 static 변수
            - 함수가 끝나도 값이 유지됨
            - 기억영역: 데이터(Data)
            - 생존기간: 영구적
            - 사용 범위: 지역적
            
            ```c
            void f() {
                static int cnt = 0;
                cnt++;
                printf("%d\n", cnt);
            }
            ```
            
        - 정적 변수 (static) - 외부 정적 변수
            - 파일 전역에 선언된 static 변수
            - 같은 파일 내에서만 접근 가능(다른 파일에서 접근 불가)
            - 기억영역: 데이터(Data)
            - 생존기간: 영구적
            - 사용 범위: 전역적(단, 파일 범위로 제한)
            
            ```c
            // a.c
            staticint g =10;// 다른 파일에서 접근 불가
            
            voidf() {
                g++;
            }
            
            ```
            
    - 외부 변수 (extern Variable)
        - 현재 파일이나 다른 파일에 정의된 전역 변수를 참조하기 위한 변수
        - 기억영역: 데이터(Data)
        - 생존기간: 영구적
        - 사용 범위: 전역적
        - 함수 밖에서 선언
        - 함수 종료 후에도 값이 소멸되지 않는다.
        - 초기화되지 않으면 자동으로 0으로 초기화
        - 다른 파일에서 선언된 변수를 참조할 경우 초기화 불가
        
        ```c
        // a.c
        int g =10;
        
        // b.c
        externint g;
        
        voidf() {
        printf("%d\n", g);
        }
        ```
        
- **한 줄 암기**
    - **auto/register = 지역 + 일시적**
    - **static = 영구적(값 유지)**
    - **extern = 다른 파일 전역 변수 참조**
    
    ```makefile
    ::contentReference[oaicite:0]{index=0}
    ```
    

**가비지 콜렉터 (Garbage Collector)**

변수를 선언만 하고 사용하지 않으면 이 변수들이 점유한 메모리 공간은 다른 프로그램들이 사용 불가

이렇게 선언만 하고 사용하지 않는 변수들이 점유한 메모리 공간을 강제로 해제하여 다른 프로그램들이 사용할 수 있도록 하는 것을 가비지 콜렉션(Garbage Collector)라 하며 이 기능을 수행하는 모듈이 가비지 콜렉터(Garbage Collector)

**변수의 선언**

자료형 변수명 = 값;

- 자료형 : 변수에 저장될 자료의 형식을 지정
- 변수명 : 사용자가 원하는 이름을 임의로 지정하나 변수명 작성 규칙에 따라 지정
- 값 : 변수를 선언하면서 초기화할 값을 지정, 선언 시 작성 불필요

## 연산자

### 연산자의 종류

**산술 연산자**

가, 감, 승, 제 등의 산술 계산에 사용되는 연산자

- 덧셈
    - +
- 뺄셈
    - -
- 곱셈
    - *
- 나눗셈
    - /
- 증감 연산자
    - ++, --
    - 전치
        - 변수 앞에 증감 연산자가 오는 형태
        - 변수의 값을 증감시킨 후 변수를 사용
    - 후치
        - 변수 뒤에 증감 연산자가 오는 형태
        - 변수 사용 뒤 변수의 값을 증감

**관계 연산자**

두 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자

- 거짓은 0, 참은 1로 사용되나 0외의 모든 숫자도 참으로 간주
- 동등 연산자
    - ==
    - !=(≠)
- 비교 연산자
    - >, >=, <, <=

**비트 연산자**

비트별(0, 1)로 연산하여 결과를 얻는 연산자

- and
    - &
    - 모든 비트가 1일 때만 1
- xor
    - ^
    - 모든 비트가 같으면 0, 하나라도 다르면 1
- or
    - |
    - 모든 비트 중 하나라도 1이면 1
- not
    - ~
    - 각 비트의 부정, 0이면 1, 1이면 0
- 왼쪽 시프트
    - <<
    - 비트를 왼쪽으로 이동 (각 진법만큼 곱셈)
- 오른쪽 시프트
    - >>
    - 비트를 오른쪽으로 이동 (각 진법만큼 나눗셈)

두 개의 논리 값을 연하여 참 또는 거짓을 반환하는 연산자

- 관계 연산자와 마찬가지로 거짓은 0, 참은 1
- not
    - !
    - 부정
- and
    - &&
    - 모두 참이면 참
- or
    - ||
    - 하나라도 참이면 참

**대입 연산자**

연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있도록 대입 연산자를 제공하며 대입 연산자는 모든 연산자에 적용 가능

+=, -=, *=, /=, %=, <<=, >>=

**조건 연산자**

조건에 따라 서로 다른 수식을 수행

- 조건 ? 수식1 : 수식2
    - 조건이 참이면 수식1 수행, 거짓이면 수식2 수행

**기타 연산자**

- sizeof
    - 자료형의 크기를 표시
- , (콤마)
    - 콤마로 구분하여 한 줄에 두 개 이상의 수식을 작성하거나 변수를 정의
    - 왼쪽에서 오른쪽으로 수행
    - a.k.a. 순서 연산자
- (자료형)
    - 사용자가 자료형을 다른 자료형으로 변환할 때 사용
    - a.k.a. cast(캐스트) 연산자
    - 변환할 자료형을 괄호 안에 넣어서 변환할 값이나 변수명 앞에 작성

### 연산자 우선순위

1. 단항 연산자
    - 단항 연산자
        - !, ~, ++, --, sizeof
    - 결합 규칙 : ←
2. 이항 연산자
    - 산술 연산자
        - +, -, *, /, %
    - 시프트 연산자
        - <<, >>
    - 관계 연산자
        - <, <=, >=, >, ==, !=
    - 비트 연산자
        - & → ^ → |
    - 논리 연산자
        - && → ||
    - 결합 규칙 : →
3. 삼항 연산자
    - 조건 연산자
        - ?  :
    - 결합 규칙 :  →
4. 대입 연산자
    - 대입 연산자
        - =, +=, -=, *=, %=, <<=, >>= 등
    - 결합 규칙 : ←
5. 순서 연산자
    - 순서 연산자
        - ,
    - 결합 규칙 : →

# 입출력과 파일 처리

## 표준 입•출력 함수

키보드로 입력받아 화면으로 출력할 때 사용하는 함수

- scanf(), getchar() gets(), printf(), putchar(), puts() 등

### C 표준 입출력

**scanf() 함수**

C 언어의 표준 입출력 함수

- 키보드로 입력받아 변수에 저장하는 함수
- **형식**
    - scanf(서식 문자열, 변수의 주소)
    - 서식 문자열 : 입력받을 데이터의 자료형을 지정
    - 변수의 주소 : 데이터를 입력받을 변수를 작성, 변수의 주소로 입력받아야 하기 때문에 주소연산자 & 사용
- **특징**
    - 입력받을 데이터의 자료형, 자릿수 등을 지정 가능
    - 한 번에 복수의 데이터 입력 가능
    - 서식 문자열과 변수의 자료형은 일치해야 한다.

**printf() 함수**

- C언어의 표준 출력 함수로 인수로 주어진 값을 화면에 출력하는 함수
- **형식**
    - printf(서식 문자열, 변수)
    - 서식 문자열 : 변수의 자료형에 맞는 서식 문자열을 작성
    - 변수의 주소 : 서식 문자열의 순서에 맞게 출력할 변수를 작성하며 scanf()와 달리 주소 연산자 &을 작성하지 않는다.

**서식 문자열**

정수형

- %d
    - 정수형 10진수를 입•출력하기 위해 사용
- %u
    - 부호없는 정수형  10진수를 입•출력하기 위해 사용
- %o
    - 정수형 8진수를 입•출력하기 위해 사용
- %x
    - 정수형 16진수를 입•출력하기 위해 사용

문자/문자열

- %c
    - 문자를 입•출력하기 위해 사용
- %s
    - 문자열을 입•출력하기 위해 사용

실수형

- %f
    - 소수점을 포함하는 실수를 입•출력하기 위해 사용
- %e
    - 지수형 실수를 입•출력하기 위해 사용

long형

- %ld
    - long형 10진수를 입•출력하기 위해 사용
- %lo
    - long형 8진수를 입•출력하기 위해 사용
- %lx
    - long형 16진수를 입•출력하기 위해 사용

포인터형

- %p
    - 주소를 16진수로 입•출력하기 위해 사용

**주요 제어문자**

입력 혹은 출력을 제어하는 문자

\n

- new line
- 커서를 다음 줄 앞으로 이동

\b

- backspace
- 커서를 왼쪽으로 한 칸 이동

\t

- tab
- 커서를 일정 간격 띄움

\r

- carriage return
- 커서를 현재 줄의 처음으로 이동

\0

- null
- 널 문자를 출력

\’

- single quote
- 작은 따옴표를 출력

\”

- double quote
- 큰 따옴표를 출력

\a

- alert
- 스피커로 벨 소리를 출력

\\

- backlash
- 역 슬래시를 출력

\f

- form feed
- 한 페이지를 이동

### 기타 표준 입•출력 함수

**입력**

getchar() 

- 키보드로 한 문자를 입력받아 변수에 저장

gets()

- 키보드로 문자열을 입력받아 변수에 저장하는 함수 [Enter]키 입력 전까지를 하나의 문자열로 인식하여 저장

**출력**

putchar()

- 인수로 주어진 한 문자를 출력하는 함수

puts()

- 인수로 주어진 문자열을 출력 후 줄바꿈

### Java 표준 입•출력

**표준 입력**

Scanner 클래스를 이용하여 키보드로 값을 입력받는 객체 변수를 생성한 수 이를 사용

- **형식**
    - Scanner  변수명 = new Scanner(표준 입력장치)
    - **입력 메소드**
        - next() : 입력값을 문자열로 반환
        - nextInt() : 입력값을 정수형으로 반환
        - nextLine() : 입력받은 라인 전체를 문자열로 반환
        - nextFloat() : 입력값을 실수형으로 반환

**표준 출력**

System 클래스의 표준 출력 스트림 out 내의 메서드를 사용

print()

- 줄바꿈 없이 출력

println()

- 출력 후 줄바꿈

printf()

- C언어와 같이 형식 지정 출력

## 파일 입•출력 함수

파일을 통해 데이터의 입•출력을 수행할 때 사용하는 함수

- fopen(), fclose(), fscanf(), fgets(), fprintf(), fputs(), fputc() 등
- 파일 입•출력 함수를 사용하기 위해서는 파일을 메모리에 저장한 후 그 위치를 가리키는 파일 포인터 변수 필요
- 파일의 입•출력은 기본적으로 파일 포인터 변수 선언 → 파일 입•출력 작업 → 파일 포인터 변수 닫기 순서로 수행

### 주요 파일 입•출력 함수

**공통**

fopen(파일명, 모드)

- 파일을 메모리에 저장한 후 그 시작 주소를 반환하는 함수
- 파일명 : 입•출력에 사용할 파일의 이름
- 모드 : 파일로 수행할 작업에 맞는 모드를 지정

fclose(파일 포인터)

- 파일 포인터 변수가 사용 중인 메모리를 해제하는 함수

파일모드의 종류

r : 파일을 읽는 용도로만 사용

w : 파일을 열어 기존의 내용을 덮어쓰며 파일이 없으면 새 파일이 생성

a : 파일을 열어 기존의 내용 끝에 이어 쓰며 파일이 없으면 새 파일이 생성

r+ : r과 w를 합친 모드이며 파일이 없으면 실행되지 않는다.

w+ : r과 w를 합친 모드이며 파일이 없으면 새 파일이 생성

a+ : r과 a를 합친 모드이며 파일이 없으면 새 파일이 생성

**입력**

fscanf(파일 포인터, 서식 문자열, 변수의 주소)

- 파일 포인터가 가리키는 위치에서 데이터를 가져와 변수에 저장하는 함수
- 서식 문자열 : 가져올 데이터의 자료형을 지정
- 변수의 주소 : 데이터를 입력받을 변수에 주소 연산자$를 붙여 입력

fgetc()

- 파일로부터 한 문자를 입력받아 저장하는 함수

fgets()

- 파일로부터 문자열을 입력받아 변수에 저장하는 함수
- [Enter] 키 입력 전까지 하나의 문자열로 인식하여 저장

**출력**

fprintf(파일 포인터, 서식 문자열, 변수)

- 파일 포인터 변수가 가리키는 위치에 변수에 저장된 데이터를 출력하는 함수
- 서식 문자열 : 출력할 변수의 자료형을 지정
- 변수 : 서식 문자열의 순서에 맞게 출력할 변수를 입력

fputc()

- 인수로 주어진 한 문자를 파일에 출력하는 함수

fputs()

- 인수로 주어진 문자열을 파일에 출력한 후 자동 줄바꿈

# 제어문

프로그램의 실행 순서를 변경할 때 사용되는 명령문

## 조건문

프로그램 실행 흐름을 조건식의 참/거짓(true/false)  결과에 따라 분기(선택) 시키는 제어문

### 단순 if문

조건에 따라서 실행할 문장을 달리하는 제어문

단순 if문은 조건이 한 개 일 때 사용하는 제어문

- 조건이 참일 때만 실행할 문장을 지정할 수도, 참과 거짓에 대해 각각 다른 실행문을 지정할 수도 있다.

### 다중 if문

조건이 여러 개일 때 사용하는 제어문

**형식 1**

- if와 else 사이에 else if문을 사용하여 조건 분기

**형식 2**

- if문 안에 if문을 포함하여 구현

### switch문

하나의 식(expression) 값을 기준으로 여러 경우(case) 중 일치하는 case로 실행 흐름을 분기하는 다중 선택 조건문

- 다중 if문으로 여러 값을 비교해야 하는 상황에서 특정 값과의 일치 여부에 따라 실행할 블록을 선택할 때 사용
- case문의 레이블에는 하나의 수만 지정할 수 있으며 int, char, enum 형의 상수만 가능
- case 문의 레이블에 변수 지정 불가능
- break문은 생략 가능하나 생략 시 수식과 레이블이 일치할 때 실행할 문장부터 break문이나 switch문 종료할 때까지 모든 문장이 실행 (or구현 가능)

switch(수식/변수) {

case 레이블1:

실행할 문장

break;

case 레이블2:

실행할 문장

break;

case 레이블3:

실행할 문장

break;

default:

실행할 문장

break;

}

### goto문

프로그램 실행 중 현재 위치에서 원하는 다른 문장으로 건너뛰어 수행을 계속하기 위해 사용하는 제어문

- 원하는 문장으로 쉽게 이동 가능하나 남용 시 프로그램 이해와 유지 보수가 어려워져 거의 사용되진 않는다.

goto 레이블;

레이블:

실행할 문장

## 반복문

특정 조건이 만족되는 동안(true) 또는 정해진 횟수만큼 같은 코드 블록을 반복 실행하도록 하는 제어문

### for문

초기값, 최종값, 증감값을 지정하는 수식을 이용해 정해진 횟수를 반복하는 제어문

- 초기값을 정한 다음 최종값에 대한 조건이 참이면 실행할 문장을 실행한 후 초기값을 증감값만큼 변경시키며 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행

for(초기값; 최종값; 증감값) {

실행할 문장

}

- 초기값, 최종값, 증감값 중 하나 이상을 생략할 수 있고 각각의 요소에 복수의 수식을 지정 가능

### while문

조건이 참인 동안 실행할 문장을 반복 수행하는 제어문

- 조건이 참인 동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문 종료
- 조건이 거짓이면 한 번도 수행되지 않는다.

while(조건) {

실행할 문장

}

### do~while문

기본적으로 while문과 같은 동작을 수행하나 실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정

- 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 반복 수행하고 거짓이면 do~while문 종료

Do {

실행할 문장

} while(조건);

### 반복 제어문

제어문의 실행을 제어하기 위해 사용되는 예약어

**break** : switc문이나 반복문 내에서 블록을 벗어난다.

**continue** : continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 이동(skip)