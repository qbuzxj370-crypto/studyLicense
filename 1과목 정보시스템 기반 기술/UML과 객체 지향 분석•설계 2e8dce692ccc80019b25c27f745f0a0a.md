# UML과 객체 지향 분석•설계

# UML

## UML (Unified Modeling Language)

시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체 지향 모델링 언어

- Rumbaugh(OMT), Booch, Jacobson 등의 객체 지향 방법론의 장점을 통합하였으며 객체 기술에 관한 국제표준화 기구 OMG(Object Management Group)에서 표준으로 지정
- UML을 이용하여 시스템의 구조를 표현하는 6개의 구조 다이어그램과 시스템의 동작을 표현하는 7개의 행위 다이어그램 작성 가능
- 각각의 다이어그램은 사물과 사물 간의 관계를 용도에 맞게 표현
- UML의 구성 요소에는 사물, 관계, 다이어그램 등이 존재

### **사물 (Things)**

다이어그램 안에서 관계가 형성될 수 있는 대상

- 모델을 구성하는 가장 중요한 기본 요소

**구조 사물(Structural Things)**

- 시스템의 개념적, 물리적 요소를 표현
- 클래스 (Class), 유스케이스 (Use Case), 컴포넌트 (Component), 노드 (Node) 등

**행동 사물(Behavioral Things)**

- 시간과 공간에 따른 요소들의 행위를 표현
- 상호작용 (Interaction), 상태 머신 (State Machine) 등

**그룹 사물(Grouping Things)**

- 요소들을 그룹으로 묶어서 표현
- 패키지 (Package)

**주해 사물(Annotation Things)**

- 부가적인 설명이나 제약 조건 등을 표현
- 노트 (Note)

### **관계 (Relationship)**

**다중도 (Multiplicity)**

클래스 간의 관계에서 인스턴스의 수

관계선의 끝에 표시

- 1 : 1개의 객체가 연관
- n : n개의 객체가 연관
- 0..1 : 연관된 객체가 없거나 1개만 존재
- 0..* 또는 * : 연관된 객체가 없거나 다수일 수 있다.
- 1..* : 연관된 객체가 적어도 1개 이상
- n..* : 연관된 객체가 적어도 n개 이상
- n..m : 연관된 객체가 최소 n개에서 최대 m개

**연관(Association) 관계**

복수의 사물이 서로 관련되어 있는 관계

- 사물 사이를 실선으로 연결하여 표현
- 방향성은 화살표로 표현
- 양방향 관계의 경우 화살표를 생략하고 실선으로 연결
- 다중도를 선 위에 표기

**집합(Aggregation) 관계**

하나의 사물이 다른 사물에 포함되어 있는 관계

- 포함하는 측(전체, Whole)과 포함되는 측(부분, Part)는 서로 독립적
- 포함되는 측에서 포함하는 측으로 속이 빈 마름모를 연결하여 표현

**포함(Composition) 관계**

집합 관계의 특수한 형태로 포함하는 사물의 변화가 포함되는 사물에 영향을 미치는 관계

- 포함하는 측(전체, Whole)과 포함되는 측(부분, Part)는 서로 독립적일 수 없고 생명 주기를 함께한다.
- 포함되는 측에서 포함하는 측으로 속이 채워진 마름모를 연결하여 표현

**일반화(Generalization) 관계**

하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계

- 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)이라 부른다.
- 구체적인 사물에서 일반적인 사물 측으로 속이 빈 화살표를 연결하여 표현

**의존(Dependency) 관계**

연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계

- 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계
- 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 측으로 점선 화살표를 연결하여 표현

**실체화(Realization) 관계**

할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계

사물에서 기능 측으로 속이 빈 점선 화살표를 연결하여 표현

### **다이어그램 (Diagram)**

사물과 관계를 도형으로 표현

- 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움
- 정적 모델링에서는 주로 구조적 다이어그램을 사용하고 동적 모델링에서는 주로 행위 다이어그램을 사용

**구조적(Structural) 다이어그램**

- 클래스(Class) 다이어그램
    - 클래스와 클래스가 가지는 속성, 클래스 간의 관계를 표현
    - 시스템의 구조를 파악하고 구조상의 문제점 도출 가능
- 객체(Object) 다이어그램
    - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
    - 럼바우(Rumbaugh) 객체 지향 분석 기법에서 객체 모델링에 활용
- 컴포넌트(Component) 다이어그램
    - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌터 간의 인터페이스를 표현
    - 구현 단계에서 사용되는 다이어그램
- 배치(Deployment) 다이어그램
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
    - 노드와 의사소통(통신) 경로로 표현
    - 구현 단계에서 사용되는 다이어그램
- 복합체 구조(Composite Structure) 다이어그램
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부를 표현
- 패키지(Package) 다이어그램
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

**행위(Behavioral) 다이어그램**

- 유스 케이스(Use Case) 다이어그램
    - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
    - 사용자(Actor)와 사용 사례(Use Case)로 구성되며 사용 사례 간에는 여러 형태의 관계로 구성
- 시퀸스(Sequence) 다이어그램
    - 상호 작용하는 시스템이나 객체들이 주고받는 메세지를 표현
- 커뮤니케이션(Communication) 다이어그램
    - 시퀸스 다이어그램과 같이 동작에 참여하는 객체 간 주고받는 메세지를 표현
    - 메세지 뿐만 아니라 객체들 간의 연관까지 표현
- 상태(State) 다이어그램
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변하는지를 표현
    - 럼바우(Rumbaugh) 객체 지향 분석 기법에서 동적 모델링에 활용
- 활동(Activity) 다이어그램
    - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
- 상호작용 개요(Interaction Overview) 다이어그램
    - 상호작용 다이어그램 간의 제어 흐름을 표현
- 타이밍(Timing) 다이어그램
    - 객체 상태 변화와 시간 제약을 명시적으로 표현

### 다이어그램의 개발 단계별 활용

- 분석 단계에서는 유스케이스 다이어그램, 클래스 다이어그램을 중심으로 요구사항을 모델링
- 설계 단계에서는 클래스 다이어그램, 시퀀스 다이어그램, 컴포넌트 다이어그램을 활용
- 구현 단계에서는 컴포넌트 다이어그램, 배치 다이어그램을 통해 물리적 구조를 표현

### **스테레오 타입 (Stereotype)**

UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용

- 길러멧(Guilemet)이라고 불리는 겹화살괄호(<<>>) 사이에 표현할 형태를 기술
- <<include>>
    - 연결이 다른 UML 요소에 대해 포함 관계에 있는 경우
- <<extend>>
    - 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우
- <<interface>>
    - 인터페이스를 정의하는 경우
- <<exception>>
    - 예외를 정의하는 경우
- <<constructor>>
    - 생성자 역할을 수행하는 경우

**include와 extend**

- **include**
    - 반드시 수행되는 공통 기능
    - 기본 유스케이스 → 포함 유스케이스
- **extend**
    - 조건부로 수행되는 선택 기능
    - 확장 유스케이스 → 기본 유스케이스

## UML 주요 다이어그램

### 유스케이스(Use Case) 다이어그램

![image.png](image%2020.png)

개발될 시스템과 관련된 외부 요소들, 즉 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점(View)에서 표현한 것

- 외부 요소와 시스템 간의 상호 작용을 확인 가능
- 사용자의 요구 사항을 분석하기 위한 도구로 사용
- 시스템의 범위를 파악 가능
- 구성 요소로는 시스템 범위, 액터, 유스케이스, 관계로 구성

**시스템 (System)/시스템 범위 (System Scope)**

- 시스템 내부에서 샤용되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스스들을 사각형으로 묶어 시스템의 범위를 표현

**액터 (Actor)**

- 시스템과 상호작용을 하는 모든 외부 요소로 사람이나 외부 시스템을 의미
- 주액터 : 시스템을 사용함으로써 이득을 얻는 대상주로 사람이 해당
- 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템. 조직이나 기관

**유스케이스 (Use Case)**

- 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것

**관계 (Relationship)**

- 액터와 유스케이스, 유스케이스와 유스케이스 사이에 나타날 수 있으며 포함 관계, 확장 관계, 일반화 관계의 3종류

### 클래스 다이어그램

![image.png](image%2021.png)

시스템을 구성하는 클래스, 클래스의 속성인 오퍼레이션, 속성과 오퍼레이션에 대한 제약 조건, 클래스 간의 관계를 표현한 것

- 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
- 시스템 구성 요소를 문서화하는데 사용
- 코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템 모델링 시 자주 사용

**클래스 (Class)**

- 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현
- 일반적으로 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기
- **속성 (Attribute)** : 클래스의 상태나 정보를 표현
- **오퍼레이션 (Operation)** : 클래스가 수행할 수 있는 동작으로 함수(메소드, Method)라고 한다.

**제약 조건**

- 속성에 입력될 값에 대한 제약 조건이나 오퍼레이션 수행 전후에 지정해야 할 조건있다면 작성

**관계 (Relationships)**

- 클래스와 클래스 사이의 연관성을 표현
- 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계 존재

**접근제어자**

속성과 오퍼레이션에 동일하게 적용

| 접근제어자 | 표현법 | 내용 |
| --- | --- | --- |
| public | + | 어떤 클래스에서라도 접근 가능 |
| private | - | 해당 클래스 내부에서만 접근 가능 |
| protected | # | 동일 패키지 내의 클래스나 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근 가능 |
| package | ~ | 동일 패키지 내부에 있는 클래스에서만 접근이 가능 |

### 순차(Sequence) 다이어그램

![image.png](image%2022.png)

시스템이나 객체들이 메세지를  주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 메세지 등의 요소를 사용하여 그림으로 표현

- 시스템이나 객체들의 상호 작용 과정에서 주고받는 메세지를 표현
- 각 동작에 참여하는 시스템이나 객체들의 수행 기관을 확인 가능
- 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현
- 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위로 하지만 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 한다.
- 액터, 객체, 생명선, 메세지 등으로 구성

**액터 (Actor)**

- 시스템으로부터 서비스를 요청하는 외부 요소
- 사람이나 외부 시스템을 의미

**객체 (Object)**

- 메세지를 주고받는 방식

**생명선 (Lifeline)**

- 객체가 메모리에 존재하는 기간
- 객체 아래에 점선을 그어 표현

**실행 상자 (Active Box)**

- 객체가 메세지를 주고받으며 구동되고 있음을 표현

**메세지 (Message)**

- 객체가 상호 작용을 위해 주고받는 메세지

# 소프트웨어 아키텍처 설계

## 소프트웨어 아키텍처

소프트웨어의 골격이 되는 기본 구조이자 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

- 소프트웨어 개발 시 적용되는 원칙과 지침이며 이해 관계자들의 의사소통 도구로 활용
- 소프트웨어 아키텍처의 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구 사항으로 나타난 제약을 반영하고 기능적 요구 사항을 구현하는 방법을 찾는 해결 과정
- 애플리케이션 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
- 소프트웨어 아키텍처 설계의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보 은닉이 있다.

### 아키텍처 뷰

복잡한 소프트웨어 시스템의 구조를 다양한 이해관계자(사용자, 개발자, 엔지니어, 관리자 등)의 관점에서 설명하기 위한 표현 방식

가장 널리 알려진 접근 방식은 4+1 뷰 모델(4+1 Architectural View Model)

**유스케이스(Use Case) 뷰**

- 시스템 외부 사용자의 관점
- 사용 사례와 이들 간의 관계를 정의하며 다른 뷰를 검증하는 용도로 사용

**논리적(Logical) 뷰**

- 설계자의 관점
- 시스템의 기능적인 요구 사항이 제공되는 방법을 설명

**구현(Implementation) 뷰**

- 개발자의 관점
- 실제 구현할 수 있는지 여부를 확인하기 위해 소프트웨어 구성을 표현

**프로세스(Process) 뷰**

- 시스템 통합자의 관점
- 자원의 효율적인 사용, 이벤트 처리 등을 표현

**배포(Deployment) 뷰**

- 테스터의 관점
- 컴포넌트가 어떻게 배치되고 연결되는지를 표현

### 설계 원리

**모듈화 (Modularity)**

소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 기능들을 모듈 단위로 나누는 것을 의미

- 자주 사용되는 계산식이나 사용자 인증 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고 너무 크게 나누면 개수가 적어 통합 비용은 적게 드나 모듈 하나의 개발 비용이 상승

**추상화 (Abstraction)**

문제의 전체적이고 포괄적인 개념을 설계한 후  차례로 세분화하여 구체화

- 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법
- 완전한 시스템을 구축하기 전 그 시스템과 유사한 모델을 만들어 여러 가지 요인들을 테스트 가능
- 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.
- 과정 추상화
    - 자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법
- 데이터 추상화
    - 데이터의 세부적인 속성이나 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
- 제어 추상화
    - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고 대표할 수 있는 표현으로 대체하는 방법

**단계적 분해 (Stepwise Refinement)**

Niklaus Wirth에 의해 제안된 하향식 설계 전략

문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법

- 추상화의 반복에 의해 세분화
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화
- 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행

**정보 은닉 (Information Hiding)**

한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

- 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉 된 모듈과의 커뮤니케이션 할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받음
- 정보 은닉을 통해 모듈을 독립적으로 수행 가능
- 하나의 모듈 변경 시 다른 모듈에 영향을 주지 않아 수정, 시험, 유지 보수가 용이

## 품질 속성과 설계 과정

### **소프트웨어 아키텍처의 품질 속성**

소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍처 측면으로 구분하여 구체화시킨 것

**시스템 설계**

| 품질 속성 | 내용 |
| --- | --- |
| 성능 | 사용자의 요청과 같은 이벤트 발생 시 이를 적적하고 빠르게 처리 |
| 보안 | 허용되지 않은 접근을 막고 허용된 접근에는 적절한 서비스를 제공 |
| 가용성 | 장애 없이 정상적으로 서비스를 제공 |
| 기능성 | 사용자가 요구한 기능을 만족스럽게 구현 |
| 사용성 | 사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확하고 편리하게 구현 |
| 변경 용이성 | 소프트웨어가 처음 설계 목표와 다른 하드웨어나 플랫폼에서도 동작할 수 있도록 구현 |
| 확장성 | 시스템의 용량, 처리능력 등을 확장 시켰을 때 이를 효과적으로 활용할 수 있도록 구현 |
| 기타 속성 | 테스트 용이성, 배치성, 안정성 등 |

**비즈니스 측면**

| 품질 속성 | 내용 |
| --- | --- |
| 시장 적시성 | 정해진 시간에 맞춰 프로그램을 출시 |
| 비용과 혜택 | 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정
유연성이 떨어지는 경우 유지 보수에 더 많은 비용이 소모될 수 있다는 것도 고려 |
| 예상 시스템 
수명 | 시스템을 얼마나 오래 사용할 것인지를 고려
수명이 길어야 한다면 시스템 품질의 ‘변경 용이성’, ‘확장성’을 중요하게 고려 |
| 기타 속성 | 목표 시장, 공개 일정, 기존 시스템과의 통합 등 |

**아키텍처 측면**

| 품질 속성 | 내용 |
| --- | --- |
| 개념적 무결성 | 전체 시스템과 시스템을 이루는 구성 요소들 간의 일관성을 유지 |
| 정확성, 완결성 | 요구 사항과 요구 사항을 구현하기 위해 발생하는 제약 사항들을 모두 충족시키는 것 |
| 구축 가능성 | 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정 변경 가능 |
| 기타 속성 | 변경성, 시험성, 적응성, 일치성, 대체성 등 |

### **아키텍처 설계 과정**

1. 설계 목표 설정
    - 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구 사항을 분석하여 전체 시스템의 설계 목표를 설정
2. 시스템 타입 결정
    - 시스템과 서브 시스템의 타입을 결정
    - 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
3. 아키텍처 패턴 적용
    - 아키텍처 패턴을 참조하여 시스템 의 표준 아키텍처를 설계
4. 서브 시스템 구체화
    - 서브 시스템의 기능 및 서브 시스템 간의 상호 작용을 위한 동작과 인터페이스를 정의
5. 검토
    - 아키텍처가 설계 목표에 부합하는지, 요구 사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토

### **시스템 타입 / 협약 기반 설계**

**시스템 타입**

특정 공통된 목적, 구조적 특성, 혹은 주요 동작 방식을 공유하는 소프트웨어 시스템들의 범주(Category) 또는 분류

해당 시스템이 무엇을 하는 시스템인고 어떻게 작동하는 시스템인가에 대한 근본적인 정체성을 정의

- 대화형 시스템
    - 사용자의 요구 발생 시 시스템이 이를 처리하고 반응하는 시스템
    - 예) 온라인 쇼핑몰과 같은 대부분의 웹 애플리케이션
- 이벤트 중심 시스템
    - 외부의 상태 변화에 따라 동작하는 시스템
    - 예) 전화, 비상벨 등의 내장 소프트웨어
- 변환형 시스템
    - 데이터 입력 시 정해진 작업들을 수행하여 결과를 출력하는 시스템
    - 예) 컴파일러, 네트워크 프로토콜 등
- 객체 영속형 시스템
    - 데이터베이스를 사용하여 파일을 효과적으로 저장•검색•갱신할 수 있는 시스템
    - 예) 서버 관리 소프트웨어

**협약(Contract)에 의한 설계**

컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세

소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세

협약에 의한 설계 시 명세에 포함되어야 할 조건

- 선행 조건 (Precondition)
    - 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- 결과 조건 (Postcondition)
    - 오퍼레이션이 수행 된 후 만족 되어야 할 조건
- 불변 조건 (Invariant)
    - 오퍼레이션이 실행되는 동안 항상 만족 되어야 할 조건

## 아키텍처 패턴

### 아키텍처 패턴

아키텍처 설계 시 참조할 수 있는 전형적인 해결 방식 또는 예제

- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
- 서브 시스템과 그 역할이 정의되어 있으며 서브 시스템 간의 관계와 여러 규칙•지침 등이 포함
- a.k.a. 아키텍처 스타일, 표준 아키텍처

**패턴 적용의 장점**

- 시행착오를 줄여 개발 시간을 단축하고 고품질의 소프트웨어 생산 가능
- 검증된 구조로 개발하므로 안정적 개발 가능
- 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통 간편화
- 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지 보수 가능
- 시스템의 특성을 개발 전에 예측하는 것이 가능
- 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등

### 주요 아키텍처 패턴

**레이어 패턴 (Layers Pattern)**

시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중 하나

- 각각의 서브 시스템들이 계층 구조를 이루며 하위 계층은 상위 계층에 대한 서비스 제공자가 되며 상위 계층은 하위 계층의 클라이언트가 된다.
- 서로 마주 보는 두 개의 계층에서만 상호작용이 이루어지며 변경 사항 적용 시에도 서로 마주 보는 두 개의 계층에서만 영향이 미치므로 변경 작업 용이
- 레이어 패턴에서는 특정 계층만을 교체해 시스템 개선 가능
- 대표적으로 OSI 참조 모델

**클라이언트–서버 패턴 (Client-Server Pattern)**

하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

- 사용자는 클라이언트와만 의사소통 가능
- 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지
- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적

**파이프–필터 패턴 (Pipe-Filter Pattern)**

데이터 스트림 절차의 독립적인 변환 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 연결 전체 처리를 구성하는 데이터 흐름 중심 아키텍처 패턴

- 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능
- 파이프는 한 필터의 출력을 다음 필터의 입력으로 전달하는 연결자 역할을 수행
- 파이프는 보통 순차 스트림이며 중간 저장소 역할도 수행한다.
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용
- 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생
- 대표적으로는 UNIX의 쉘(Shell)

**모델–뷰–컨트롤러 패턴 (Model-View-Controller Pattern)**

서브 시스템을 3개의 부분으로 구조화하는 패턴

- 각 부분의 역할
    - 모델 (Model) : 각 서브 시스템의 핵심 기능과 데이터를 보관
    - 뷰 (View) : 사용자에게 정보를 출력
    - 컨트롤러 (Controller) : 사용자로부터 받은 입력을 처리
- 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업 수행 가능
- 다수의 뷰를 만들 수 있으므로 하나의 모델에 대해 여러 개의 뷰를 필요로 하는 애플리케이션에 적합

### **기타 아키텍처 패턴**

**마스터-슬레이브 패턴 (Master-Slave Pattern)**

마스터 컴포넌트는 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴

- 마스터는 모든 작업의 주체이며 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 적업을 수행하여 결과를 반환
- 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 활용

**브로커 패턴 (Broker Pattern)**

사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결

- 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
- 분산 환경 시스템에서 주로 활용

**피어-투-피어 패턴 (Peer-To-Peer Pattern)**

피어(Peer)를 하나의 컴포넌트로 간주하며 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴

- 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용

**이벤트-버스 패턴 (Event-Bus Pattern)**

소스가 특정 채널에 이벤트 메세지를 발행(Publish)하면 해당 채널을 구독(SubScribe)한 리스너들이 메세지를 받아 이벤트를 처리하는 방식

주요 컴포넌트

- 소스 (Source) : 이벤트 생성
- 리스너 (Listener) : 이벤트를 수행
- 채널 (Channel) : 이벤트의 통로
- 버스 (Bus) : 채널들을 관리

**블랙보드 패턴 (Blackboard Pattern)**

모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태

- 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터 탐색 가능
- 해결책이 명확하지 않은 문제 처리에 유용한 패턴
- 음성 인식, 차량 식별, 신호 해석 등에 주로 사용
- 구성 컴포넌트
    - 블랙보드 (blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리
    - 지식 소스 (knowledge source) : 자체 표현을 가진 특수 모듈
    - 제어 컴포넌트 (control component) : 모듈 선택, 설정 및 실행을 담당

**인터프리터 패턴 (Interpreter Pattern)**

프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성

- 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트 설계 시 사용

# 객체 지향 개념과 분석·설계

## 객체 지향 (Object-Oriented)

현실 세계의 개체(Entity)를 부품처럼 하나의 객체(Object)로 만들어 기계의 부품을 조립하여 제품을 만들 듯 소프트웨어 개발 시에도 객체들을 조립해서 필요한 소프트웨어를 작성하는 기법

- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지 보수가 쉽다.
- 복잡한 구조를 단계적•계층적으로 표현하고 멀티미디어 및 병렬 처리를 지원
- 현실 세계를 모형화하여 사용자와 개발자가 쉽게 이해

### 객체 (Object)

데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈

**데이터**

객체가 자지고 있는 정보

- 속성이나 상태 분류 등을 의미
- a.k.a 속성(Attribute), 상태, 변수, 상수, 자료 구조

**함수**

객체가 수행하는 기능

- 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘
- 객체의 상태를 참조하거나 변경하는 수단
- a.k.a 메소드(Method, 행위), 서비스(Service), 동작(Operation), 연산

**객체의 특성**

- 객체는 독립적으로 식별 가능한 이름을 보유
- 객체가 가질 수 있는 조건을 상태(State)라고 하며 일반적으로 시간에 따라 변경
- 객체 간에는 상호 연관성에 의한 관계가 형성
- 객체가 반응할 수 있는 메세지(Message)의 집합을 행위라 하며 객체는 행위의 특징을 표현 가능
- 객체는 일정한 기억장소를 보유
- 객체의 메소드는 다른 객체로부터 메세지를 받았을 때 정해진 기능을 수행

### 클래스 (Class)

공통된 속성과 연산(행위)을 갖는 객체의 집합, 객체의 일반적인 타입(Type)을 의미

- 각각의 객체들이 갖는 속성과 연산을 정의하는 틀
- 객체지향 프로그래밍에서 데이터를 추상화하는 단위
- 클래스에 속한 각각의 객체들을 인스턴스(Instance)라 하며 클래스로부터 새로운 객체를 생성하는 것이 인스턴스화(Instantiation)
- 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지며 그속성에 해당하는 정보가 서로 달라 동일 기능을 하는 여러 가지 객체를 나타낸다.
- 최상위 클래스는 상위 클래스를 가지지 않는 클래스를 의미

**클래스의 종류**

- 슈퍼 클래스 (Super Class)
    - 특정 클래스의 상위(부모) 클래스
- 서브 클래스 (Sub Class)
    - 특정 클래스의 하위(자식) 클래스
- 추상 클래스 (Abstract Class)
    - 구체 클래스에서 구현하려는 기능들의 공통점만을 모아 추상화한 클래스
    - 인스턴스 생성 불가능
    - 구체 클래스가 추상 클래스를 상속받아 구체화 후 구체 클래스의 인스턴스를 생성하는 방식으로 사용
- 구체 클래스 (Concrete Class)
    - 인스턴스 생성이 가능한 일반적인 클래스를 의미하는 용어
    - 추상 클래스와 구분하기 위해 사용
    - a.k.a. 구상 클래스, 구현 클래스

### 캡슐화 (Encapsulation)

데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미

- 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과 축소
- 캡슐화된 객체들은 재사용이 용이
- 객체들 간 메세지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고 객체 간의 결합도가 낮아진다.

### 상속 (Inheritance)

이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

- 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용 가능
- 하위 클래스는 상위 클래스로부터 상속 받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 다시 사용 가능
- 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용(Reuse)을 높일 수 있는 중요 개념
- **다중 상속(Multiple Inhertance)** : 하나의 클래스가 복수의 상위 클래스로부터 속성과 연산을 상속받는 것

### 다형성 (Polymorphism)

메세지에 의해 객체(클래스)가 연산 수행 시 하나의 메세지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력

- 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답
- 응용 프로그램 상에서 하나의 함수나 연산자가 복수의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행 가능
- 예) ‘+’연산자와 경우 숫자 클래스 간에는 덧셈, 문자열 클래세서는 문자열의 연결 기능으로 사용

### 연관성 (Relationship)

복수의 객체들이 상호 참조하는 관계

**is member of**

- 연관화 (Association)
- 복수의 객체가 상호 관련되어 있음을 의미

**is instance of**

- 분류화 (Classfication)
- 동일한 형의 특성을 갖는 객체들을 모아 구성

**is part of**

- 집단화 (Aggregation)
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성

**is a**

- 일반화 (Generalization)
    - 공통적인 성질들로 추상화한 상위 객체를 구성
- 특수화/상세화 (Specialization)
    - 상위 객체를 구체화하여 하위 객체를 구성

## 객체 지향 분석

### 객체 지향 분석 (OOA, Object Oriented Analysis)

사용자의 요구 사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업

- 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석
- 분석가에게 주요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 도와준다.
- 객체는 클래스로부터 인스턴스화되고 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적

**객체 지향 분석의 주요 산출물**

- 클래스 후보 목록
- 객체, 속성, 연산 정의
- 클래스 다이어그램
- 유스케이스 명세서
- 객체 간 관계 정의

### 객체 지향 분석의 방법론

객체 지향 분석은 사용자의 요구 사항과 관련된 객체, 속성, 연산 관계 등을 정의하여 모델링하는 작업

- 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석
- 클래스를 식별하는 것이 객체 지향 분석의 주요 목적

**Rumbaugh(럼바우) 방법**

- 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행

**Booch(부치) 방법**

- 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의

**Jacobson 방법**

- 유스 케이스를 강조하여 사용

**Coad와 Yourdon 방법**

- E-R 다이어크램을 사용하여 객체의 행위를 모델링
- 객체 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메세지 연결 정의 등의 과정으로 구성

**Wirfs-Brock 방법**

- 분석과 설계 간 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

### 럼바우(**Rumbaugh**) 분석 기법

모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법

- a.k.a. 객체 모델링 기법 (OMT, Object-Modeling Technique)
- 분석 활동은 객체 모델링 → 동적 모델링 → 기능 모델링 순으로 진행4

**객체 모델링 (Object Modeling)**

- a.k.a. 정보 모델링
- 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시

**동적 모델링 (Dynamic Modeling)**

- 상태 다이어그램을 이용
- 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현 하는 모델링

**기능 모델링 (Funtional Modeling)**

- 자료 흐름도(DFD)를 이용
- 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체 지향 설계 원칙 (SOLID)

시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙

다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고도 불린다. (SRP, OCP, LSP, ISP, DIP)

**단일 책임 원칙 (SRP, Single Responsibility Principle)**

객체는 단 하나의 책임만을 가져야 하는다는 원칙

- 응집도는 높게, 결합도는 낮게 셜계하는 것을 의미

**개방-폐쇄 원칙 (OCP, Open-Closed Principle)**

기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙

- 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적

**리스코프 치환 원칙 (LSP, Liskov Substitution Principle)**

자식 클래스는 최소한 부모 클래스에서 가능한 행위는 할 수 있어야 한다는 원칙

- 자식 클래스는 부모 클랫의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.

**인터페이스 분리 원칙 (ISP, Interpace Segregation Principle)**

자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙

- 단일 책임 원칙이 객체가 갖는 하나의 책임이라면 인터페이스 분리 원칙은 인터페이스가 가지는 하나의 책임

**의존 역전 원칙 (DIP, Dependency Inversion Principle)**

각 객체들 간 의존 관계 성립 시 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

- 일반적으로 인터페이스 활용 시 이 원칙은 준수된다.

**SOLID 원칙과 디자인 패턴의 관계**

- OCP, DIP 원칙은 전략 패턴, 팩토리 패턴 적용으로 구
- ISP 원칙은 퍼사드, 어댑터 패턴과 연관

# 디자인 패턴

## 디자인 패턴의 개요

### 디자인 패턴(Design Pattern)

모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미

- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
- ‘바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)’라는 말과 같이 개발 과정 중 문제 발생 시 새로로 해결책을 구상하기 보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
- 디자인 패턴은 한 패턴에 변형을 가하거나 특정 요구 사항을 반영하면 유사한 다른 패턴으로 변화하는 특징이 있다.
- 1995년 GoF(Gang of Four)라 불리는 에릭 감마(Eric Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Jonson), 존 블라시디스(John Vlissides)가 처음으로 구체화 및 체계화
- GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용 가능한 패턴들을 분류하여 정리함으로써 지금까지로도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴
- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성

### 아키텍처 패턴과 디자인 패턴의 차이

모두 소프트웨어 설계를 위한 참조 모델이나 다음과 같은 차이가 존재

- 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용
- 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면 디자인 패턴은 서브 시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
- 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용

### 디자인 패턴 사용의 장•단점

- 범용적인 코딩 스타일로 인해 구조 파악이 용이
- 객체 지향 설계 및 구현의 생산성을 높이는데 적합
- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약
- 초기 투자 비용이 부담될 수 있다.
- 개발자 간 원활한 의사소통이 가능
- 설계 변경 요청에 대한 유연한 대처가 가능
- 객체 지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 부적합

## 디자인 패턴의 유형

### 생성 패턴 (Creational Pattern)

객체의 생성과 관련된 패턴

- 5개의 패턴 존재
- 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램의 유연성 향상

**추상 팩토리 (Abstarct Factory)**

구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관•의존하는 객체들의 그룹으로 묶어 생성하고 추상적으로 표현

- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능

**빌더 (Builder)**

작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성

- 객체의 생성 과정과 표현 과정을 분리하여 동일한 객체 생성에서도 서로 다른 결과 출력 가능

**팩토리 메소드 (Factory Method)**

객체 생성을 서브 클래스에서 처리하도록 분리하여 갭슐화한 패턴

- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
- a.k.a. 가상 생성자(Virtual Constructor) 패턴

**프로토타입 (Prototype)**

원본 객체를 복제하는 방법으로 객체를 생성하는 패턴

- 일반적인 방법으로 객체를 생성
- 비용이  큰 경우 주로 이용

**싱글톤 (Singleton)**

하나의 객체를 생성하면 생성된 객체를 어디서든 참조 가능하나 여러 프로세스가 동시에 참조 불가능

- 클래스 내에서 인스턴스가 하나뿐임을 보장하고 그 인스턴스에 대한 전역 접근 지점(global access point)을 제공
- 불필요한 메모리 낭비 최소화
- 전역 상태를 객체로 안전하게 관리하기 위한 패턴

### 구조 패턴 (Structural Pattern)

구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

**어댑터 (Adapter)**

호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용 할 수 있도록 변환해주는 패턴

- 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

**브리지 (Bridge)**

구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴

- 기능과 구현을 두 개의 별도 클래스로 구현

**컴포지트 (Composite)**

여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴

- 객체들을 트리 구조로 구성
- 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현 가능

**데코레이터 (Decorator)**

객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴

- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

**퍼싸드 (Facade)**

복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴

- 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체 필요

**플라이웨이트 (Flyweight)**

인스턴스가 필요할 때마다 매번 생성하지 않고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴

- 다수의 유사 객체를 생성하거나 조작 시 유용하게 사용 가능

**프록시 (Proxy)**

접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

- 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

### 행위 패턴 (Behavioral Pattern)

클래스나 객체들이 서로 상호 작용하는 방법이나 책임 분배 방법을 정의하는 패턴

- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화

**책임 연쇄 (Chain of Responsibility)**

요청을 처리 가능한 객체가 둘 이상 존재하면 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴

- 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다.

**커맨드 (Command)**

요청을 객체의 형태로 캡슐화 하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴

- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화

**인터프리터 (Interpreter)**

언어에 문법 표현을 정리하는 패턴

- SQL이나 통신 프로토콜과 같은 것을 개발 할 때 사용

**반복자 (Iterator)**

자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴

- 내부 표현 방법의 노출 없이 순차적 접근 가능

**중재자 (Mediator)**

수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴

- 객체 간의 의존성을 줄여 결합도 감소
- 중재자는 객체 간의 통제와 지시의 역할을 수행

**메멘토 (Memento)**

특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴

- 되돌리기 기능 개발 시 주로 이용

**옵서버 (Observer)**

한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴

- 주로 분산된 시스템 간에 이벤트를 생성•발행(Publish)하고 이를 수신(Subsribe)해야 할 때 이용

**상태 (State)**

객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴

- 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리

**전략 (Strategy)**

동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴

- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용 가능
- 클라이언트에 영향 없이 알고리즘의 변경이 용이

**템플릿 메소드 (Template Method)**

상위 클래스에서 골격을 정의하고 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴

- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지 보수를 용이하게 해준다.

**방문자 (Vistor)**

각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

- 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행