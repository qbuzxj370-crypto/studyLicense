# 소프트웨어 개발 환경과 테스트

# 개발 환경 및 협업 도구

## 개발 환경

### 통합 개발 환경 (IDE, Integrated Development Environment)

코딩, 디버그, 컴파일, 베포 등 프로그램 개발과 관련된 모든 작업을 하나의 프로그램에서 처리할 수 있도록 제공하는 소프트웨어적인 개발 환경

- 기존 소프트웨어 개발에서는 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 별도로 사용했으나 현재는 하나의 인터페이스로 통합하여 제공
- 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미

| 프로그램 | 개발사 | 플랫폼 | 운영체제 | 지원 언어 |
| --- | --- | --- | --- | --- |
| 이클립스 (Eclipse) | Eclipse Foundation, IBM | 크로스 
플랫폼 | Windows, Linux, 
MacOS 등 | Java, C, C++, PHP, JSP 등 |
| 비주얼 스튜디오 
(Visual Studio) | Microsoft | Win32,
Win64 | Windows | Basic, C,C++,
C#, .NET 등 |
| 엑스 코드 (Xcode) | Apple | Mac,
iPhone | MacOS, iOS | C, C++, C#, Java, AppleScript 등 |
| 안드로이드 스튜디오
(Android Studio) | Google | Android | Windows, Linux, 
MacOS | Java, C, C++ |
| IDEA | JetBrains 
(이전 IntelliJ) | 크로스
플랫폼 | Windows, Linux, 
MacOS | Java, JSP, XML, 
Go, Kotlin, PHP 등 |

통합 개발 환경 도구의 대표적 기능

**코딩 (Coding)**

- C, JAVA 등의 프로그래밍 언어로 프로그램을 작성하는 기능

**컴파일 (Compile)**

- 개발자가 작성한 고급 언어로 된 소스 파일을 컴퓨터가 이해 가능한 목적 프로그램으로 번역하여 컴퓨터에서 실행 가능한 형태로 변환하는 기능

**디버깅 (Debugging)**

- 소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 버그(Bug)를 찾아 수정하는 기능

**배포 (Deployment)**

- 소프트웨어를 사용자에게 전달하는 기능

### 빌드 도구

빌드 (Build) : 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물

- 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Complie) 등의 작업들을 수행하는 소프트웨어
- 대표적인 도구로는 Ant, Maven, Gradle

**Ant (Another Neat Tool)**

- 아파치 소프트웨어 재단에서 개발한 소프트웨어, 자바 프로젝트의 공식적인 빌드 도구로 사용
- XML 기반의 빌드 스크립트를 사용
- 자유도와 유연성이 높아 복잡하느 빌드 환경에도 대처 가능
- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의하며 스크립트의 재사용이 어렵다.

**Maven**

- Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으로 Ant의 대안으로 개발
- 규칙이나 표준이 존재하여 예외 사항만 기록하면 되며 컴파일과 빌드를 동시에 수행 가능
- 의존성(Dependency)을 설정하여 라이브러리를 관리

**Gradle**

- 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구
- 한스 도커(Docker) 외 6인의 개발자가 모여 공동 개발
- 안드로이드 스튜디오의 공식 빌드 도구로 채택
- Maven과 동일하게 의존성을 활용
- 그루비(Groovy) 기반의 빌드 스크립트를 사용

### 협업 도구

개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구(Tool)로 협업 소프트웨어, 그룹웨어(Groupware) 등으로 불린다.

- 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 보조 도구 포함
- 웹 기반, PC, 스마트폰 등 다양한 플랫폼에서 사용할 수 있도록 제공
- 협업 도구에 익숙하지 않거나 이용할 의지가 없으면 협업 도구가 오히려 협업의 방해 요소가 될 수 있다.

**프로젝트 및 일정 관리**

전체 프로젝트와 개별 업무들의 진행 상태, 일정 등을 공유하는 기능을 제공

- 종류 : 구글 캘린더(Google Calendar), 분더리스트(Wunderlist), 트렐로(Trello), 지라(Jira), 플로우(Flow) 등

**정보 공유 및 커뮤니케이션**

주제별로 구성원들을 지목하여 방을 개설한 후 정보를 공유하고 대화하는 것이 가능

- 간편한 파일 관리와 자유로운 의사소통이 특징
- 종류 : 슬랙(Slack), 잔디(Jandi), 태스크월드(Taskworld) 등

**디자인**

디자이너가 설계한 UI나 이미지의 정보들을 코드화하여 개발자에게 전달하는 기능

- 종류 : 스케치(Sketch), 제플린(Zeplin) 등

**기타**

- 아이디어 공유에 사용되는 에버노트 (Evernote)
- API를 문서화하여 개발자들 간 협업을 도와주는 스웨거 (Swagger)
- 깃(Git)의 웹호스팅 서비스인 깃허브 (GitHub)

# 애플리케이션 테스트 개요

## 테스트의 기본 개념

### 애플리케이션 테스트

애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 혹은 절차

- 개발된 소프트웨어가 고객의 요구 사항을 만족시키는지 확인(Validation)하고 소프트웨어가 기능을 정확히 수행하는지 검증(Verification)한다.
- 테스트 실행 전에 개발한 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트 할 사항 정리 필요
- 애플리케이션 테스트는 목적(업무/제어/개발)과 환경(하드웨어/사용자/네트워크)에 따라 검증 관점이 달라진다.

**시스템 소프트웨어 (System Software)**

하드웨어를 제어하고 응용 소프트웨어 실행 환경을 제공하는 소프트웨어

- 운영체제, 컴파일러, 디바이스 드라이버, 미들웨어 등
- 성능, 안정성, 자원 관리 테스트가 중요
- 메모리 관리, 프로세스 스케줄링, 입출력 처리 검증
- 장시간 실행에 대한 부하·스트레스 테스트 필요

**응용 소프트웨어 (Application Software)**

사용자의 특정 업무나 목적을 수행하기 위한 소프트웨어

- 업무용 프로그램, 웹 애플리케이션, 모바일 앱
- 기능 요구사항 충족 여부 중심 테스트
- 입력값 처리, 업무 흐름, UI/UX 검증
- 단위 테스트 → 통합 테스트 → 시스템 테스트 순으로 수행

**개발 소프트웨어 (Development Software)**

다른 소프트웨어를 개발하기 위해 사용하는 도구용 소프트웨어

- IDE, 빌드 도구, 형상관리 도구, 테스트 도구
- 정확성, 신뢰성, 호환성 테스트 중요
- 오류 발생 시 전체 개발 과정에 영향
- 자동화 테스트 도구의 결과 신뢰성 검증 필요

**임베디드 소프트웨어 (Embedded Software)**

특정 하드웨어에 내장되어 동작하는 전용 소프트웨어

- 가전제품, 차량 제어 시스템, 의료기기
- 실시간성, 신뢰성, 하드웨어 연동 테스트 중요
- 응답 시간, 인터럽트 처리, 예외 상황 검증
- 시뮬레이션 테스트 활용 빈도 높음

**패키지 소프트웨어 (Package Software)**

불특정 다수를 대상으로 제작·배포되는 범용 소프트웨어

- ERP, 회계 패키지, 오피스 프로그램
- 범용성, 설정 변경 기능 테스트 중요
- 다양한 OS, DB, 브라우저 환경 호환성 검증
- 사용자 커스터마이징 기능 테스트 필요

**웹 애플리케이션 / 모바일 애플리케이션**

**웹 애플리케이션**

- 브라우저 호환성 테스트
- 네트워크 오류 대응 검증
- 보안 테스트(SQL Injection, 인증·인가)

**모바일 애플리케이션**

- 다양한 단말기 해상도 대응
- 배터리 사용량 테스트
- 네트워크 전환(Wi-Fi ↔ LTE) 처리 검증

### 애플리케이션 테스트의 필요성/기본 원리

**애플리케이션 테스트의 필요성**

- 프로그램 실행 전 오류를 발견하여 예방
- 프로그램이 사용자의 요구 사항이나 기대 수준 등을 만족 시키는지 반복적으로 테스트하므로 제품의 신뢰도를 향상
- 애플리케이션의 개발 초기부터 애플리케이션 테스트를 기획하고 시작하면 단순  오류 발견 뿐만 아니라 새로운 오류의 유입 또한 예방 가능
- 효과적인 애플리케이션 테스트의 수행은 최소한의 시간과 노력으로 많은 결함 발견 가능

**애플리케이션 테스트의 기본 원리**

- 소프트웨어의 잠재적인 결함을 줄일 수 있지만 소프트웨어에 결함이 없다고 증명할 수는 없다. ∴완벽한 소프트웨어 테스팅은 불가능
- 애플리케이션의 결함은 대부분 개발자의 특성이나 애플리케이션의 기능적 특징 때문에 특정 모듈에 집중
- 애플리케이션의 20%에 해당하는 코드에서 전체 80%의 결함이 발견된다고 하여 파레토 법칙 적용 가능
- 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스(Pesticide Parodox) 현상 발견
- 정황 의존성 원리(Context Dependence)
    - 테스트 결과는 소프트웨어 특성, 환경, 테스터 역량 등 정황(Context)에 따라 달라질 수 있다.
    - 정황에 따라 다른 테스트를 수행
- 소프트웨어 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 할 수 없다. 이를 오류 부재의 궤변(Absence of Errors Fallacy)
- 테스트는 작은 부분에서 시작해서 점점 확대하며 진행해야 한다.
- 테스트는 개발자와 관계없는 별도의 팀에서 수행해야 한다.
- 완벽한 테스트 불가능, 파레토 법칙, 살충제 패러독스, 테스팅은 정황 의존, 오류-부재의 궤변, 테스트와 위험은 반비례, 테스트의 점진적 확대, 태스트의 별도 팀 수행

## 테스트 분류 기준

### 프로그램 실행 여부에 따른 테스트

**정적 테스트**

프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트

- 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용
- 종류 : 워크스루, 인스펙션, 코드 검사 등

**동적 테스트**

프로그램을 실행하여 오류를 찾는 테스트

- 소프트웨어 개발의 모든 단계에서 테스트를 수행
- 종류 : 블랙박스 테스트, 화이트박스 테스트

### 테스트 기반(Test Bases)에 따른 테스트

**명세 기반 테스트**

사용자의 요구 사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트

- 종류 : 동등 분할, 경계 값 분석 등

**구조 기반 테스트**

소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트

- 종류 : 구문 기반, 결정 기반, 조건 기반 등

**경험 기반 테스트**

유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트

- 사용자의 요구 사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 효과적
- 종류 : 에러 추정, 체크 리스트., 탐색적 테스팅

### 테스트 시점에 따른 테스트

**검증(Verification) 테스트**

개발자의 시각에서 제품의 생산 과정을 테스트

- 제품이 명세서대로 완성됐는지를 테스트

**확인(Validation) 테스트**

사용자의 시각에서 생산된 제품의 결과를 테스트

- 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트

### 테스트 목적에 따른 테스트

**회복(Recovery) 테스트**

- 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인

**안전(Security) 테스트**

- 시스템에 설치된 보호 도구가 불법적인 침입으로부터 시스템을 보호 할 수 있는지를 확인하는 테스트

**강도(Stress) 테스트**

- 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트

**성능(Performance) 테스트**

- 소프트웨어의 실시간 성능이나 효율성을 진단하는 테스트
- 소프트웨어의 응답 시간, 처리량 등을 테스트

**구조(Structure) 테스트**

- 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트

**회귀(Regression) 테스트**

- 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트

**병행(Parallel) 테스트**

- 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트

# 테스트 기법

## 화이트박스 테스트 (White Box Test)

모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법

- 설계된 절차에 초점을 둔 구조적 테스트
- 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계
- 모듈 안의 작동을 직접 관찰
- 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어

### 화이트박스 테스트의 종류

**기초 경로 검사 (Base Path Testing)**

테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법

- 대표적인 화이트박스 테스트 기법

**제어 구조 검사 (Control Structure Testing)**

- 조건 검사 (Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트케이스 설계 기법
- 루프 검사 (Loop Testing) : 프로그램의 반복 구조에 초첨을 맞춰 실시하는 테스트 케이스 설계 기법
- 데이터 흐름 검사 (Data Flow Testing) : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법

### 화이트박스 테스트의 검증 기준

테스트 케이스들이 테스트에 얼마나 적저한지를 판단하는 기준

**문장 검증 기준 (Statement Coverage)**

- 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스 설계

**분기 검증 기준 (Branch Coverage)**

- a.k.a. 결정 검증 기준(Decision Coverage)
- 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계

**조건 검증 기준 (Condition Coverage)**

- 소스 코드의 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계

**분기/조건 기준 (Branch/Condition Coverage)**

- 분기 검증 기준과 조건 검증 기준을 모두 만족하는 설계
- 조건문이 True인 경우와 False인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계

### 검증 기준(Covarage)의 유형

**기능 기반 커버리지** 

- 실제 테스트가 수행된 기능의 수/전체 기능의 수

**라인 커버리지 (Line Coverage)**

- 테스트 시나리오가 수행한 코드의 라인 수/전체 코드의 라인 수

**코드 커버리지 (Code Coverage)**

- 소스 코드의 구문, 분기, 조건 등의 구조 코드 자체가 얼마나 테스트 되었는지를 측정하는 방법

## 블랙박스 테스트 (Black Box Test)

소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트

- a.k.a. 기능 테스트
- 사용자의 요구 사항 명세서를 보면서 테스트하며 주로 구현된 기능을 테스트
- 소프트웨어 인터페이스에서 실시되는 테스트
- 부정확하거나 누락된 기능, 인터페이스 오류 등을 발견하기 위해 사용되며 테스트 후반부에 적용
- 동치 분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사 등

### 블랙박스 테스트의 종류

**동치 분할 검사 (Equivalence Partitioning Testing, 동치 클래스 분해)**

- 프로그램 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고 해당 자료에 맞는 결과가 출력되는지 확인하는 기법
- a.k.a. 동등 분할 기법

**경계값 분석 (Boundary Value Analysis)**

- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용
- 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법

**원인-효과 그래프 검사 (Cuase-Effect Graphing Testing)**

- 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법

**오류 예측 검사 (Error Testing)**

- 과거의 경험이나 확인자의 감각으로 테스트하는 기법

**비교 검사 (Comparison Testing)**

- 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

## 개발 단계에 따른 테스트

애플리케이션 테스트는 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류되며 이렇게 분류된 단계를 테스트 레벨이라고 한다.

- 애플리케이션 테스트는 소프트웨어의 개발 단계에서부터 테스트를 수행하므로 단순히 소프트웨어어에 포함된 코드 상의 오류 뿐만 아니라 요구 분석의 오류, 설계 인터페이스 오류 등도 발견 가능
- 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것이 V-모델

![image.png](image%2023.png)

### **단위 테스트 (Unit Test)**

코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트

- 단위 테스트에서는 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사
- 사용자의 요구 사항을 기반으로 한 기능성 테스트를 최우선으로 수행
- 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 실행
- 단위 테스트로 발생 가능한 오류 : 알고리즘 오류에 따른 원치 않는 결과, 탈출구가 없는 반복문의 사용, 틀린 계산 수식에 의한 잘못된 결과

테스트 방법

**구조 기반 테스트**

프로그램 내부 구조 및 시간 복잡도를 검증하는 화이트박스 테스트 시행

- 테스트 목적 : 제어 흐름, 조건 결정

**명세 기반 테스트**

목적 및 실행 코드 기반의 블랙박스 테스트 시행

- 테스트 목적 : 동등 분할, 경계 값 분석

### **통합 테스트 (Integration Test)**

단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미

- 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사

### **시스템 테스트 (System Test)**

개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트

- 환경적인 장애 리스크를 최소화하기 위해서는 실제 사용 환경과 유사하게 만든 테스트 환경에서의 테스트 수행 필요
- 기능적 요구 사항과 비기능적 요구 사항으로 구분하여 각각을 만족시키는지 테스트

**기능적 요구 사항**

- 요구사항 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트 시행

**비기능적 요구사항**

- 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 웹 페이지의 네비게이션 등 구조적 요소에 대한 화이트박스 페스트 시행

### **인수 테스트 (Acceptance Test)**

개발한 소프트웨어가 사용자의 요구 사항을 충족하는지에 중점을 두고 테스트하는 방법

- 개발한 소프트웨어를 사용자가 직접 테스트
- 테스트 결과 문제가 없으면 사용자는 소프트웨어를 인수하게 되고 프로젝트는 종료
- 6가지 종류로 구분해서 테스트
    
    **사용자 인수 테스트**
    
    - 사용자가 시스템 사용의 적절성 여부를 확인
    
    **운영상의 인수 테스트**
    
    - 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법
    - 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인
    
    **계약 인수 테스트**
    
    - 계약상의 인수/검수 조건을 준수하는지 여부
    
    **규정 인수 테스트**
    
    - 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지를  확인
    
    **알파 테스트**
    
    - 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법
    - 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록
    
    **베타 테스트**
    
    - 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법
    - a.k.a. 필드 테스팅 (Field Testing)
    - 실업무를 가지고 사용자가 직접 테스트
    - 개발자에 의해 제어되지 않은 상태에서 테스트 수행
    - 발견된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고

# 통합 테스트 전략

## 통합 테스트 **(Integration Test)** 방식

단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법

**비점진적 통합 방식**

단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트 하는 방법으로 빅뱅 통합 테스트 방식이 있다.

- 규모가 작은 소프트웨어에 유리하며 단시간 내에 테스트가 가능
- 전체 프로그램을 대상으로 하기 때문에 오류 발견 및 장애 위치 파악 및 수정 난해

**점진적 통합 방식**

모듈 단위로 단계적으로 통합하면서 테스트하는 방법

- 하향식, 상향식, 혼합식 통합 방식
- 오류 수정이 용이
- 인터페이스와 연관된 오류를 완전히 테스트할 가능성이 높다.

### 하향식 통합 테스트 **(Top Down Integration Test)**

프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법

- 주요 제어 모듈을 기준으로 하여 아래 단계로 이동하면서 통합하는데 이때 깊이 우선 통합법이나 넓이 우선 통합법 사용
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있다.
- 상위 모듈에는 태스트 케이스를 사용하기 어렵다.

**하향식 통합 방법 수행 절차**

1. 주요 제어 모듈은 작성된 프로그램을 사용하고 주요 제어 모듈의 종속 모듈들은 스텁(Stub)으로 대체
2. 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈로 교체
3. 모듈 통합 시마다 테스트를 실시
4. 새로운 오류가 발생하지 않음을 보증하기 위한 회귀 테스트를 실시
    
    ※ 깊이 우선 통합법
    주요 제어 모듈을 중심으로 해당 모듈에 종속된 모든 모듈을 통합하는 것으로, 다음 그림에 대한 통합 순서는 A1, A2, A3, A4, A5, A6, A7, A8, A9 순
    
    ![image.png](image%2024.png)
    
    ※ 넓이 우선 통합법
    
    구조의 수평을 중심으로 해당하는 모듈을 통합하는 것으로, 다음 그림에 대한 통합 순서는 A1, A2, A3, A4, A5, A6, A7, A8, A9 순
    
    ![image.png](image%2025.png)
    

### 상향식 통합 테스트 **(Bottom Up Integration Test)**

프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법

- 최하위 단계의 모듈에서 통합 테스트라 수행되므로 스텁 불필요
- 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요

**상향식 통합 테스트 수행 절차**

1. 하위 모듈을 클러스터(Cluster)로  결합
2. 상위 모듈에서 데이터의 입•출력을 확인하기 위해 더미 모듈인 드라이버(Driver)를 작성
3. 통합된 클러스터 단위로 테스트
4. 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체

### 테스트 드라이버와 테스트 스텁

| 구분 | 드라이버 (Driver) | 스텁 (Stub) |
| --- | --- | --- |
| 개념 | 테스트 대상의 하위 모듈을 호출하는 도구로, 매개변수(Parameter)를 전달하고 모듈 테스트 수행 후 결과를 도출 | 제어 모듈이 호출하는 타 모듈의 기능을 단순화하여 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 시험용으로 만든 모듈. |
| 필요 시기 | 상위 모듈 없이 하위 모듈이 있는 경우 하위 모듈 구동 | 상위 모듈은 있지만 하위 모듈이 없는 경우 하위 모듈 대체 |
| 테스트 방식 | 상향식(Bottom Up) 테스트 | 하향식(Top Down) 테스트 |
| 공통점 | 소프트웨어 개발과 테스트를 병행할 경우 이용 |  |
| 차이점 | • 이미 존재하는 하위 모듈과 존재하지 않는 상위 모듈 간의 인터페이스 역할 수행
• 소프트웨어 개발이 완료되면 드라이버는 본래의 모듈로 교체 | • 일시적으로 필요한 조건만을 가지고 제공되는 간단한 가짜 모듈의 역할
•  시험용 모듈이기 때문에 일반적으로 드라이버보다 작성이 쉽다. |

![ChatGPT Image 2026년 1월 20일 오후 04_08_52.png](ChatGPT_Image_2026%EB%85%84_1%EC%9B%94_20%EC%9D%BC_%EC%98%A4%ED%9B%84_04_08_52.png)

![ChatGPT Image 2026년 1월 20일 오후 04_08_41.png](ChatGPT_Image_2026%EB%85%84_1%EC%9B%94_20%EC%9D%BC_%EC%98%A4%ED%9B%84_04_08_41.png)

### 혼합식 통합 테스트 **(Hybrid/Sandwich Integration Testing)**

하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식

- a.k.a. 샌드위치(Sandwich)식 통합 테스트 방법

### 회귀 테스팅 (Regression Testing)

이미 테스트된 프로그램에 테스팅을 반복

통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트

- 수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트
- 모든 테스트 케이스를 이용해 테스트하는 것이 최선이나 시간과 비용이 많이 필요하므로 기존 테스트 케이스 중 변경된 부분을 테스트할 수 있는  테스트 케이스만을 선정하여 수행

**회귀 테스트의 테스트 케이스 선정 방법**

- 모든 애플리케이션의 기능을 수행할 수 있는 대표적인 테스트 케이스를 선정
- 애플리케이션 기능 변경에 따른 파급 효과를 분석하여 파급 효과가 높은 부분이 포함된 테스트 케이스를 선정
- 실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스를 선정

# 결함 관리

## 결함 관리 프로세스

**결함(Fault)**

오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것을 의미

- 사용자가 예상한 결과와 실행 결과 간의 차이나 업무 내용 불일치 등으로 인해 변경이 필요한 부분도 모두 결함에 해당

### 결함 관리 절차

1. 결함 관리 계획
    - 전체 프로세스에 대한 결함 관리 일정, 업무 프로세스 등을 확보하여 계획을 수립
2. 결함 기록
    - 테스터는 발견된 결함을 결함 관리 DB에 등록
3. 결함 검토
    - 테스터, 프로그램 리더, 품질관리(QA) 담당자 등은 등록된 결함을 검토하고 결함을 수정할 개발자에게 전달
4. 결함 수정
    - 개발자는 전달받은 결함을 수정
5. 결함 재확인
    - 테스터는 개발자가 수정한 내용을 확인하고 다시 테스트 수행
6. 결함 상태 추적 및 모니터링 활동
    - 결함 관리 DB을 이용하여 프로젝트별 결함 유형, 발생률 등을 한눈에 볼 수 있는 대시보드 또는 게시판 형태의 서비스를 제공
7. 최종 결함 분석 및 보고서 작성
    - 발견된 결함에 대한 정보와 이해관계자들의 의견이 반영된 보고서를 작성하고 결함 관리를 종료

### 결함 상태 추적

테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리

- 발견된 결함에 대해 결함 관리 지표의 속성 값들을 분석하여 향후 결함이 발견될 모듈 혹은 컴포넌트 추정 가능
- 결함 관리 측정 지표
    - 결함 분포
        - 모듈 또는 컴포넌트의 특성 속성에 해당하는 결함 수 측정
    - 결함 추세
        - 테스트 진행 시간에 따른 결함 수의 추이 분석
    - 결함 에이징
        - 특정 결함 상태로 지속되는 시간 측정

### 결함 추적 순서

1. 결함 등록 (Open)
    - 테스터와 품질 관리(QA) 담당자에 의해 발견된 결함이 등록된 상태
2. 결함 검토 (Reviewed)
    - 등록된 결함이 테스터, 품질 관리(QA) 담당자, 프로그램 리더, 담당 모듈 개발자에 의해 검토된 상태
3. 결함 할당 (Assigned)
    - 결함을 수정하기 위해 개발자와 문제 해결 담당자에게 결함이 할당된 상태
4. 결함 수정 (Resolved)
    - 개발자가 결함 수정을 완료한 상태
5. 결함 조치 분류 (Deferred)
    - 결함의 수정이 불가능해 연기된 상태
    - 우선순위, 일정 등에 따라 재오픈을 준비 중인 상태
6. 결함 종료 (Closed)
    - 결함이 해결되어 테스터와 품질 관리 담당자가 종료를 승인한 상태
7. 결함 해제 (Clarified)
    - 테스터, 프로그램 리더, 품질 관리 담당자가 종료 승인한 결함을 검토하여 결함이 아니라고 판명한 상태

## 결함 분류 및 우선순위

### 결함 분류

테스트에서 발견되는 결함을 유형별로 분류

**시스템 결함**

- 시스템 다운, 애플리케이션의 작동 정지, 종료, 응답, 시간 지연, 데이터베이스 에러 등
- 주로 애플리케이션 환경이나 데이터베이스 처리에서 발생된 결함

**기능 결함**

- 사용자의 요구 사항 미반영/불일치, 부정확한 비즈니스 프로세스, 스크립트 오류, 타 시스템 연동 시 오류 등
- 애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함

**GUI 결함**

- UI 비일관성, 데이터 타입의 표시 오류, 부정확한 커서/메세지 오류 등
- 사용자 화면 설계에서 발생된 결함

**문서 결함**

- 사용자의 요구 사항과 기능 요구 사항의 불일치로 인한 불완전한 상태의 문서
- 사용자의 온라인/오프라인 메뉴얼의 불일치 등
- 기획자, 사용자, 개발자 간의 의사소통 및 기록이 원활핮지 않아 발생된 결함

### 테스트 단계별 유입 결함

**기획 시 유입되는 결함**

- 사용자 요구 사항의 표준 미준수로 인한 테스트 불가능
- 요구사항 불명확/불완전/불일치 등

**설계 시 유입되는 결함**

- 설계 표준 미준수로 인한 테스트 불가능
- 기능 설계 불명확/불완전/불일치 등

**코딩 시 유입되는 결함**

- 코딩 표준 미준수로 인한 기능의 불완전/불일치, 데이터 결함, 인터페이스 결함 등

**태스트 부족으로 유입되는 결함**

- 테스트 수행 시 테스트 완료 기준의 미준수
- 테스트팀과 개발팀의 의사소통 부족, 개발자의 코딩 실수 등

### 결함 심각도

애플리케이션에 발생한 결함이 전체 시스탬에 미치는 치명도를 나타내는 척도

결함 심각도를 우선순위에 따라 분류

**High**

- 핵심 요구 사항 미구현, 장시간 시스템 응답 지연, 시스템 다운 등과 같이 더 이상 프로세스를 진행할 수 없도록 만드는 결함

**Medium**

- 부정확한 기능이나 데이터베이스 에러 등과 같이 시스템 흐름에 영향을 미치는 결함

**Low**

- 부정확한 GUI 및 메세지, 에러 시 메세지 미출력, 화면상의 문법/철자 오류 등과 같이 시스템 흐름에는 영향을 미치지 않는 결함

### 결함 우선순위

발견된 결함 처리에 대한 신속성을 나타내는 척도

결함의 중요도와 심각도에 따라 설정되고 수정 여부가 결정

- 일반적으로 결함의 심각도가 높으면 우선순위도 높지만 애플리케이션이 특성에 따라 우선 순위가 결정될 수도 있기 때문에 심각도가 높다고 반드시 우선 순위가 높지는 않다.
- 결함 우선 순위는 결정적(Critical), 높음(High), 보통(Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등

### 결함 관리 도구

**Mantis**

- 결함 및 이슈 관리 도구
- 소프트웨어 설계 시 단위별 작업 내용을 기록할 수 있어 결함 추적이 가능한 도구

**Trac**

결함 추적은 물론 결함을 통합하여 관리할 수 있는 도구

**Redmine**

프로젝트 관리 및 결함 추적이 가능한 도구

**Buggzilla**

- 결함 신고, 확인, 처리 등 결함을 지속적으로 관리할 수 있는 도구
- 결함의 심각도와 우선 순위를 지정 가능